# Project Directory Structure

📁 ./
  📄 next-env.d.ts
  📄 package-lock.json
  📄 package.json
  📄 postcss.config.js
  📄 tailwind.config.ts
  📄 tsconfig.json
  📁 public/
    📄 drake-meme.png
    📄 meme-1.png
    📄 meme-10.png
    📄 meme-11.png
    📄 meme-12.png
    📄 meme-13.png
    📄 meme-14.png
    📄 meme-15.png
    📄 meme-16.png
    📄 meme-17.png
    📄 meme-18.png
    📄 meme-19.png
    📄 meme-2.png
    📄 meme-20.png
    📄 meme-21.png
    📄 meme-22.png
    📄 meme-23.png
    📄 meme-24.png
    📄 meme-25.png
    📄 meme-26.png
    📄 meme-27.png
    📄 meme-28.png
    📄 meme-29.png
    📄 meme-3.png
    📄 meme-30.png
    📄 meme-31.png
    📄 meme-32.png
    📄 meme-33.png
    📄 meme-34.png
    📄 meme-35.png
    📄 meme-36.png
    📄 meme-37.png
    📄 meme-38.png
    📄 meme-39.png
    📄 meme-4.png
    📄 meme-40.png
    📄 meme-41.png
    📄 meme-42.png
    📄 meme-43.png
    📄 meme-44.png
    📄 meme-45.png
    📄 meme-46.png
    📄 meme-47.png
    📄 meme-48.png
    📄 meme-49.png
    📄 meme-5.png
    📄 meme-50.png
    📄 meme-6.png
    📄 meme-7.png
    📄 meme-8.png
    📄 meme-9.png
  📁 src/
    📁 contexts/
      📄 ToastContext.tsx
    📁 app/
      📄 globals.css
      📄 layout.tsx
      📄 page.tsx
    📁 components/
      📄 AppShell.tsx
      📄 Header.tsx
      📄 ImageModal.tsx
      📄 MemeGenerator.tsx
      📄 Preloader.tsx
      📄 Toast.tsx
      📁 ui/
        📄 Button.tsx
        📄 Card.tsx
    📁 hooks/
      📄 useToasts.ts


# File Contents

File: next-env.d.ts
================================================================================
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.


--------------------------------------------------------------------------------

File: tailwind.config.ts
================================================================================
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: ["class"],
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;


--------------------------------------------------------------------------------

File: package.json
================================================================================
{
  "name": "meme-generator",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "clsx": "^2.1.1",
    "framer-motion": "^11.2.10",
    "jszip": "^3.10.1",
    "lucide-react": "^0.395.0",
    "next": "14.2.4",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "@types/jszip": "^3.4.0",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.4.19",
    "eslint": "^8",
    "eslint-config-next": "14.2.4",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}


--------------------------------------------------------------------------------

File: tsconfig.json
================================================================================
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


--------------------------------------------------------------------------------

File: postcss.config.js
================================================================================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


--------------------------------------------------------------------------------

File: src/contexts/ToastContext.tsx
================================================================================
"use client";

import { createContext, useState, useCallback, ReactNode } from 'react';
import Toast from '../components/Toast';

type ToastMessage = {
  id: number;
  message: string;
  duration?: number;
};

interface ToastContextType {
  addToast: (message: string, duration?: number) => void;
}

export const ToastContext = createContext<ToastContextType | undefined>(undefined);

export function ToastProvider({ children }: { children: ReactNode }) {
  const [toasts, setToasts] = useState<ToastMessage[]>([]);

  const addToast = useCallback((message: string, duration?: number) => {
    const id = Date.now();
    setToasts((prevToasts) => [...prevToasts, { id, message, duration }]);
  }, []);

  const removeToast = useCallback((id: number) => {
    setToasts((prevToasts) => prevToasts.filter((toast) => toast.id !== id));
  }, []);

  return (
    <ToastContext.Provider value={{ addToast }}>
      {children}
      <div className="toast-container">
        {toasts.map((toast) => (
          <Toast
            key={toast.id}
            id={toast.id}
            message={toast.message}
            duration={toast.duration}
            onDismiss={removeToast}
          />
        ))}
      </div>
    </ToastContext.Provider>
  );
}


--------------------------------------------------------------------------------

File: src/app/layout.tsx
================================================================================
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({
  subsets: ["latin", "cyrillic"],
  display: "swap",
  variable: "--font-inter",
});

export const metadata: Metadata = {
  title: "Meme Generator",
  description: "Создайте свой собственный мем!",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="ru" className="dark">
      <body className={`${inter.variable} font-sans antialiased`}>
        {children}
      </body>
    </html>
  );
}


--------------------------------------------------------------------------------

File: src/app/page.tsx
================================================================================
import AppShell from "../components/AppShell";

export default function HomePage() {
  return <AppShell />;
}


--------------------------------------------------------------------------------

File: src/app/globals.css
================================================================================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  color-scheme: dark;
}

body {
  background-image: url('/bg.jpg');
  background-size: cover;
  background-position: center;
  background-attachment: fixed;
  position: relative; /* Needed for pseudo-element positioning */
  color: white; /* Ensure text remains white */
}

body::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5); /* Dark overlay */
  z-index: -1; /* Place behind content */
}

/* Анимация для внешнего контейнера: держит его видимым, а в конце растворяет */
@keyframes preloader-fade-out {
  0%,
  50% {
    opacity: 1;
  }
  100% {
    opacity: 0;
  }
}

/* Анимация для внутреннего элемента: линия -> вспышка. Больше не исчезает сама. */
@keyframes tv-on {
  /* Этап 1: Развертка линии до полного экрана */
   0% {
    transform: scaleY(0.005);
    opacity: 1;
    background: radial-gradient(ellipse at center, #bbbbbb 0%, #999999 20%, #000000 60%);
    filter: brightness(1.6); /* Небольшое свечение в центре при старте */
  }
  40% {
    transform: scaleY(1);
    opacity: 1;
    background: radial-gradient(ellipse at center, #aaaaaa 0%, #888888 30%, #000000 70%);
    filter: brightness(1.2);
  }
  /* Этап 2: Мягкий серый экран, который затем растворяется */
  50%, 100% {
    transform: scaleY(1);
    background: #999999; /* Стабильный, неяркий серый цвет */
    filter: brightness(1); /* Убираем фильтр, чтобы цвет был чистым */
    opacity: 1;
  }
}

.tv-boot {
  animation: tv-on 2.5s ease-in-out forwards;
}

/* Сканлайны + виньетка */
.tv-scanlines::after {
  content: "";
  position: absolute;
  inset: 0;
  background-image: linear-gradient(rgba(255,255,255,0.05) 1px, transparent 1px);
  background-size: 100% 3px;
  mix-blend-mode: overlay;
  opacity: 0.35;
  animation: scan-flicker 2s linear infinite;
}

/* Подсветка новых карточек в дашборде */
@keyframes pulse-glow {
  0%   { box-shadow: 0 0 0px rgba(220,38,38,0.0); transform: scale(1); }
  25%  { box-shadow: 0 0 30px rgba(220,38,38,0.6); transform: scale(1.01); }
  50%  { box-shadow: 0 0 18px rgba(220,38,38,0.35); transform: scale(1.005); }
  75%  { box-shadow: 0 0 28px rgba(220,38,38,0.5); transform: scale(1.01); }
  100% { box-shadow: 0 0 0px rgba(220,38,38,0.0); transform: scale(1); }
}
.new-meme-highlight {
  animation: pulse-glow 1.4s ease-out 1;
}

@keyframes scan-flicker {
  0%,
  100% {
    opacity: 0.25;
  }
  50% {
    opacity: 0.4;
  }
}

@keyframes pulse-button {
  0% {
    transform: scale(1);
    box-shadow: 0 0 0 rgba(255, 255, 255, 0.7);
  }
  70% {
    transform: scale(1.05);
    box-shadow: 0 0 20px rgba(255, 255, 255, 0);
  }
  100% {
    transform: scale(1);
    box-shadow: 0 0 0 rgba(255, 255, 255, 0);
  }
}

.pulse-animation {
  animation: pulse-button 1.5s infinite;
}

.tv-vignette::after {
  content: "";
  position: absolute;
  inset: 0;
  box-shadow: inset 0 0 200px rgba(0, 0, 0, 0.9);
  pointer-events: none;
}

/* Стили для уведомлений (Toast) */
.toast-container {
  position: fixed;
  bottom: 1.5rem;
  right: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  z-index: 100;
}

.toast-item {
  display: flex;
  align-items: center;
  background-color: #8fbc8f; /* soft green */
  color: rgb(0, 0, 0);
  padding: 1rem;
  border-radius: 0.5rem;
  border: 1px solid #374151; /* gray-700 */
  box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  opacity: 0;
  transform: translateX(100%);
  transition: all 0.3s ease-in-out;
}

.toast-item-visible {
  opacity: 1;
  transform: translateX(0);
}


--------------------------------------------------------------------------------

File: src/components/ImageModal.tsx
================================================================================
"use client";

import { useEffect } from 'react';
import { ChevronLeft, ChevronRight, X } from 'lucide-react';
import Image from 'next/image';

type MemeItem = { id: number; src: string; kind: "user" | "feed" };

interface ImageModalProps {
  meme: MemeItem;
  memeTitle: string;
  onClose: () => void;
  onNext: () => void;
  onPrev: () => void;
  hasNext: boolean;
  hasPrev: boolean;
}

export default function ImageModal({
  meme,
  memeTitle,
  onClose,
  onNext,
  onPrev,
  hasNext,
  hasPrev,
}: ImageModalProps) {
  // Убираем состояние загрузки, так как мы полагаемся на предзагрузку

  // Обработчик событий клавиатуры
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') onClose();
      if (e.key === 'ArrowRight' && hasNext) onNext();
      if (e.key === 'ArrowLeft' && hasPrev) onPrev();
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [onClose, onNext, onPrev, hasNext, hasPrev]);

  return (
    <div
      className="fixed inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center"
      onClick={onClose}
    >
      <div
        className="relative bg-neutral-900 p-4 md:p-6 rounded-xl border border-neutral-700 w-11/12 max-w-4xl max-h-[90vh] flex flex-col gap-4"
        onClick={(e) => e.stopPropagation()}
      >
        <div className="flex justify-between items-center">
          <h3 className="font-bold text-xl">{memeTitle}</h3>
          <button onClick={onClose} className="p-2 rounded-full hover:bg-neutral-800 transition-colors">
            <X size={24} />
          </button>
        </div>

        {/* Контейнер для изображения. Теперь без спиннера и логики загрузки. */}
        <div className="relative flex-grow flex items-center justify-center">
          <Image
            key={meme.id}
            src={meme.src}
            alt={memeTitle}
            width={1000}
            height={1000}
            className="max-w-full max-h-[70vh] w-auto h-auto object-contain"
            priority // Повышаем приоритет загрузки
          />
        </div>
      </div>

      {/* Стрелки навигации */}
      {hasPrev && (
        <button
          onClick={(e) => { e.stopPropagation(); onPrev(); }}
          className="absolute left-4 top-1/2 -translate-y-1/2 p-2 bg-black/50 rounded-full hover:bg-black/80 transition-colors z-10"
        >
          <ChevronLeft size={32} />
        </button>
      )}
      {hasNext && (
        <button
          onClick={(e) => { e.stopPropagation(); onNext(); }}
          className="absolute right-4 top-1/2 -translate-y-1/2 p-2 bg-black/50 rounded-full hover:bg-black/80 transition-colors z-10"
        >
          <ChevronRight size={32} />
        </button>
      )}
    </div>
  );
}

--------------------------------------------------------------------------------

File: src/components/AppShell.tsx
================================================================================
"use client";

import { useState, useEffect, useRef } from "react";
import Preloader from "./Preloader";
import MemeGenerator from "./MemeGenerator";
import { Header } from "./Header";
import { ToastProvider } from "../contexts/ToastContext";

export default function AppShell() {
  const [bootDone, setBootDone] = useState(false);
  const audioRef = useRef<HTMLAudioElement>(null);
  // 1. Начинаем со звуком, но готовы к тому, что браузер его заблокирует.
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const audio = audioRef.current;
    if (!audio) return;

    // 2. Как только прелоадер закончил, пытаемся запустить музыку
    if (bootDone) {
      audio.volume = 0.5;
      audio.muted = isMuted;

      // Пытаемся включить. Если не получится (из-за правил браузера),
      // то ждем первого клика от пользователя.
      const playPromise = audio.play();
      if (playPromise !== undefined) {
        playPromise.catch(() => {
          // Если автозапуск со звуком не удался, включаем его по первому клику
          const enableSoundOnClick = () => {
            setIsMuted(false);
            audio.play();
            window.removeEventListener('click', enableSoundOnClick);
            window.removeEventListener('keydown', enableSoundOnClick);
          };
          window.addEventListener('click', enableSoundOnClick);
          window.addEventListener('keydown', enableSoundOnClick);
        });
      }
    }
  }, [bootDone, isMuted]);

  return (
    <ToastProvider>
      <div className="flex flex-col min-h-screen text-white relative">
        <audio ref={audioRef} src="/bst.mp3" loop />
        {!bootDone && <Preloader onBootComplete={() => setBootDone(true)} />}
        <Header isMuted={isMuted} onToggleMute={() => setIsMuted(!isMuted)} />
        <main className="flex-grow flex items-center justify-center p-4 pt-20">
          <MemeGenerator />
        </main>
      </div>
    </ToastProvider>
  );
}


--------------------------------------------------------------------------------

File: src/components/MemeGenerator.tsx
================================================================================
"use client";

import { useState, useRef, useEffect } from "react";
import JSZip from "jszip";
import Image from "next/image";
import { Button } from "./ui/Button";
import ImageModal from "./ImageModal";
import { useToasts } from "../hooks/useToasts";

type MemeItem = { id: number; src: string; isNew?: boolean; kind: "user" | "feed" };

// Функция для предзагрузки изображений в кэш браузера
const preloadImage = (src: string) => {
  const img = new window.Image();
  img.src = src;
};

export default function MemeGenerator() {
  const [text, setText] = useState("");
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const imageRef = useRef<HTMLImageElement>(null);
  const [imageLoaded, setImageLoaded] = useState(false);
  const feedTimerRef = useRef<number | null>(null);
  const highlightTimeouts = useRef<number[]>([]);

  const MEME_POOL = [
    "/drake-meme.png",
    ...Array.from({ length: 50 }).map((_, i) => `/meme-${i + 1}.png`),
  ];

  const [generatedMemes, setGeneratedMemes] = useState<MemeItem[]>([]);

  // Modal State
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [selectedMemeId, setSelectedMemeId] = useState<number | null>(null);

  const { addToast } = useToasts();
  const MAX_STORED_MEMES = 100; // Define a reasonable limit for stored memes

  // Хелпер для создания пачки новых мемов
  const createNewFeedMemes = (count: number) => {
    return Array.from({ length: count }).map((_, index) => ({
      id: Date.now() + Math.random() + index,
      src: MEME_POOL[Math.floor(Math.random() * MEME_POOL.length)],
      kind: "feed" as const,
    }));
  };

  // Загружаем мемы из localStorage при первой загрузке, или создаем новые
  useEffect(() => {
    try {
      const savedMemes = localStorage.getItem('generatedMemes');
      if (savedMemes) {
        const parsedMemes = JSON.parse(savedMemes);
        if (Array.isArray(parsedMemes) && parsedMemes.length > 0) {
          // Если нашли, добавляем 15 новых в начало
          const newMemesOnRefresh = createNewFeedMemes(15);
          setGeneratedMemes([...newMemesOnRefresh, ...parsedMemes]);
          return; // Загрузили, выходим
        }
      }
    } catch (error) {
      console.error("Ошибка загрузки мемов из localStorage:", error);
    }
    // Резервный вариант для самого первого посещения
    setGeneratedMemes(createNewFeedMemes(111));
  }, []); // Пустой массив зависимостей гарантирует, что это выполнится только один раз

  // Сохраняем мемы в localStorage при каждом их изменении
  useEffect(() => {
    if (generatedMemes.length > 0) {
      try {
        localStorage.setItem('generatedMemes', JSON.stringify(generatedMemes.slice(0, MAX_STORED_MEMES)));
      } catch (error) {
        if (error instanceof DOMException && error.name === 'QuotaExceededError') {
          console.error("QuotaExceededError: Failed to save memes. Storage limit reached.", error);
          addToast("Ошибка: достигнут лимит хранилища! Старые мемы могут не сохраниться.");
        } else {
          console.error("Error saving memes to localStorage:", error);
        }
      }
    }
  }, [generatedMemes, addToast]); // Added addToast to dependency array

  useEffect(() => {
    const image = new window.Image();
    image.src = "/drake-meme.png";
    image.crossOrigin = "anonymous";
    image.onload = () => {
      if (imageRef.current) {
        imageRef.current.src = image.src;
        setImageLoaded(true);
      }
    };
  }, []);

  const openModal = (id: number) => {
    setSelectedMemeId(id);
    setIsModalOpen(true);
  };

  const closeModal = () => {
    setIsModalOpen(false);
    setSelectedMemeId(null);
  };

  const selectedMemeIndex = selectedMemeId !== null
    ? generatedMemes.findIndex((meme) => meme.id === selectedMemeId)
    : -1;
  const selectedMeme = selectedMemeIndex !== -1 ? generatedMemes[selectedMemeIndex] : null;

  const showNextMeme = () => {
    if (selectedMemeIndex !== -1 && selectedMemeIndex < generatedMemes.length - 1) {
      setSelectedMemeId(generatedMemes[selectedMemeIndex + 1].id);
    }
  };

  const showPrevMeme = () => {
    if (selectedMemeIndex > 0) {
      setSelectedMemeId(generatedMemes[selectedMemeIndex - 1].id);
    }
  };

  const generateMeme = () => {
    const canvas = canvasRef.current;
    const image = imageRef.current;
    if (canvas && image && imageLoaded && text.trim()) {
      const ctx = canvas.getContext("2d");
      if (ctx) {
        canvas.width = image.naturalWidth;
        canvas.height = image.naturalHeight;
        ctx.drawImage(image, 0, 0);
        ctx.fillStyle = "white";
        const fontSize = canvas.width * 0.045;
        ctx.font = `${fontSize}px Arial, sans-serif`;
        ctx.textBaseline = "middle";
        const yPos = canvas.height * 0.90;
        const metrics = ctx.measureText(text);
        const textHeight = fontSize * 1.4;
        const textWidth = metrics.width + fontSize * 0.5;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
        ctx.textAlign = "left";
        ctx.fillRect(40, yPos - textHeight / 2, textWidth, textHeight);
        ctx.fillStyle = 'white';
        ctx.fillText(text, 40 + fontSize * 0.25, yPos);

        const newMemeUrl = canvas.toDataURL("image/png");
        const newMeme: MemeItem = { id: Date.now(), src: newMemeUrl, kind: "user" };

        setGeneratedMemes(prev => [newMeme, ...prev]);
        setText("");
        openModal(newMeme.id);
      }
    }
  };

  const handleSaveAll = async () => {
    const zip = new JSZip();
    generatedMemes.forEach((item, index) => {
      if (item.kind === "user" && item.src.startsWith("data:image/")) {
        const memeNumber = generatedMemes.length - index;
        const base64Data = item.src.split(",")[1];
        zip.file(`meme-${memeNumber}.png`, base64Data, { base64: true });
      }
    });
    const content = await zip.generateAsync({ type: 'blob' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(content);
    link.download = 'memes-dashboard.zip';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
  };

  useEffect(() => {
    const scheduleNext = () => {
      const delay = Math.floor(Math.random() * 900) + 100;
      feedTimerRef.current = window.setTimeout(() => {
        const randomSrc = MEME_POOL[Math.floor(Math.random() * MEME_POOL.length)];
        const newMeme: MemeItem = { id: Date.now() + Math.random(), src: randomSrc, kind: "feed", isNew: true };
        setGeneratedMemes(prev => [newMeme, ...prev]);
        const memeNumber = generatedMemes.length + 1;
        addToast(`A new bother has appeared: Bother #${memeNumber}`);

        const t = window.setTimeout(() => {
          setGeneratedMemes(prev =>
            prev.map(meme =>
              meme.id === newMeme.id ? { ...meme, isNew: false } : meme
            )
          );
        }, 1400);
        highlightTimeouts.current.push(t);
        scheduleNext();
      }, delay);
    };
    scheduleNext();
    return () => {
      if (feedTimerRef.current) clearTimeout(feedTimerRef.current);
      highlightTimeouts.current.forEach((id) => clearTimeout(id));
      highlightTimeouts.current = [];
    };
  }, [addToast, generatedMemes.length]);

  return (
    <>
      <div className="flex flex-col items-center w-full max-w-4xl mx-auto">
        <h1 className="text-4xl font-bold text-center text-white mb-8">
          Tell what bothers you
        </h1>
        <div className="relative w-full max-w-xl min-h-[300px] bg-neutral-800 rounded-lg flex items-center justify-center overflow-hidden border border-neutral-700 mx-auto">
          <img ref={imageRef} alt="Meme template" className="hidden" />
          <canvas ref={canvasRef} className="hidden" />
          <img src="/drake-meme.png" alt="Meme template" className="w-full h-auto" />
          <input
            type="text"
            placeholder="Enter text..."
            value={text}
            onChange={(e) => setText(e.target.value)}
            onKeyDown={(e) => {
              if (e.key === 'Enter') generateMeme();
            }}
            style={{ textShadow: '1px 1px 2px rgba(0,0,0,0.7)' }}
            className="absolute bottom-[10%] left-4 w-3/4 p-4 bg-black bg-opacity-30 border-2 border-dashed border-gray-400 rounded-md text-white text-xl focus:outline-none focus:border-solid focus:border-white transition"
          />
        </div>
        <div className="mt-6">
          <Button onClick={generateMeme} variant="light" className="px-12 py-3 text-lg pulse-animation">
            THAT BOTHERS ME
          </Button>
        </div>
        {generatedMemes.length > 0 && (
          <div className="w-full mt-12 border-t-2 border-neutral-700 pt-8">
            <h2 className="text-3xl font-bold text-center mb-6">What bothers others</h2>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
              {generatedMemes.map((item, index) => (
                <div
                  key={item.id}
                  className={`flex flex-col gap-3 p-4 bg-neutral-800 rounded-lg border border-neutral-700 transition-shadow cursor-pointer hover:border-purple-600 ${
                    item.isNew ? "new-meme-highlight" : ""
                  }`}
                  onClick={() => openModal(item.id)}
                  onMouseEnter={() => preloadImage(item.src)}
                >
                  <div className="relative w-full aspect-square">
                    <Image
                      src={item.src}
                      alt={`Bother #${generatedMemes.length - index}`}
                      fill
                      sizes="(max-width: 640px) 100vw, (max-width: 1024px) 50vw, 25vw"
                      className="object-cover rounded-md"
                    />
                  </div>
                  <p className="text-center font-semibold">
                    Bother #{generatedMemes.length - index}
                  </p>
                </div>
              ))}
            </div>
            <div className="text-center mt-8">
              <Button onClick={handleSaveAll} variant="primary" className="py-3 text-lg px-12">
                Сохранить Все (.zip)
              </Button>
            </div>
          </div>
        )}
      </div>

      {isModalOpen && selectedMeme && (
        <ImageModal
          meme={selectedMeme}
          memeTitle={
            selectedMeme.kind === 'user'
              ? 'Your Creation'
              : `Bother #${generatedMemes.length - (selectedMemeIndex ?? 0)}`
          }
          onClose={closeModal}
          onNext={showNextMeme}
          onPrev={showPrevMeme}
          hasNext={selectedMemeIndex !== -1 && selectedMemeIndex < generatedMemes.length - 1}
          hasPrev={selectedMemeIndex > 0}
        />
      )}
    </>
  );
}


--------------------------------------------------------------------------------

File: src/components/Preloader.tsx
================================================================================
"use client";

export default function Preloader({
  onBootComplete,
}: {
  onBootComplete: () => void;
}) {
  return (
    <div
      className="fixed inset-0 z-50 flex items-center justify-center bg-black overflow-hidden"
      style={{ animation: "preloader-fade-out 2.5s ease-out forwards" }}
      onAnimationEnd={onBootComplete}
    >
      {/* Виньетка + сканлайны */}
      <div className="absolute inset-0 pointer-events-none tv-vignette" />
      <div className="absolute inset-0 pointer-events-none tv-scanlines" />

      {/* Анимация «включение ТВ» */}
      <div className="tv-boot w-full h-full" />

      <div className="absolute bottom-10 text-neutral-300 text-sm opacity-70">
        <span className="animate-pulse">booting CRT…</span>
      </div>
    </div>
  );
}


--------------------------------------------------------------------------------

File: src/components/Header.tsx
================================================================================
"use client";

import { Copy, X, Volume2, VolumeX } from "lucide-react";
import { useState } from "react";

export function Header({
  isMuted,
  onToggleMute,
}: {
  isMuted: boolean;
  onToggleMute: () => void;
}) {
  const [copied, setCopied] = useState(false);
  const contractAddress = "0x1234...5678"; // Замените на ваш адрес

  const copyToClipboard = () => {
    navigator.clipboard.writeText(contractAddress);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  return (
    <header className="fixed top-0 left-0 right-0 z-40 bg-black/30 backdrop-blur-sm">
      <div className="container mx-auto flex items-center justify-between p-4 text-white">
        {/* Left: Coin Name */}
        <div className="text-2xl font-bold tracking-wider">
          RYOK?
        </div>

        {/* Center: Contract Address */}
        <div className="flex items-center gap-2 px-4 py-2 bg-neutral-800/50 border border-neutral-700 rounded-full text-sm">
          <span className="hidden sm:inline">Contract:</span>
          <span className="font-mono">{contractAddress}</span>
          <button onClick={copyToClipboard} className="transition-transform hover:scale-110 active:scale-95">
            {copied ? <span className="text-green-400 text-xs">Copied!</span> : <Copy size={16} />}
          </button>
        </div>

        {/* Right: Icons */}
        <div className="flex items-center gap-6">
          <button onClick={onToggleMute} className="transition-transform hover:scale-110">
            {isMuted ? <VolumeX size={24} /> : <Volume2 size={24} />}
          </button>
          <a href="https://x.com" target="_blank" rel="noopener noreferrer" className="transition-transform hover:scale-110">
            <X size={24} />
          </a>
        </div>
      </div>
    </header>
  );
}


--------------------------------------------------------------------------------

File: src/components/Toast.tsx
================================================================================
"use client";

import { X } from 'lucide-react';
import { useEffect, useState } from 'react';

interface ToastProps {
  id: number;
  message: string;
  duration?: number;
  onDismiss: (id: number) => void;
}

export default function Toast({ id, message, duration = 2000, onDismiss }: ToastProps) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    setVisible(true); // Trigger fade-in animation
    const timer = setTimeout(() => {
      setVisible(false);
      setTimeout(() => onDismiss(id), 300); // Wait for fade-out to complete
    }, duration);

    return () => clearTimeout(timer);
  }, [id, duration, onDismiss]);

  const handleDismiss = () => {
    setVisible(false);
    setTimeout(() => onDismiss(id), 300);
  };

  return (
    <div className={`toast-item ${visible ? 'toast-item-visible' : ''}`}>
      <p className="flex-grow">{message}</p>
      <button onClick={handleDismiss} className="ml-4 p-1">
        <X size={18} />
      </button>
    </div>
  );
}


--------------------------------------------------------------------------------

File: src/components/ui/Card.tsx
================================================================================
import React from 'react';
import clsx from 'clsx';

interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export const Card = ({ className, children, ...props }: CardProps) => {
  return (
    <div className={clsx('bg-neutral-800 border border-neutral-700 rounded-xl shadow-soft p-6', className)} {...props}>
      {children}
    </div>
  );
};


--------------------------------------------------------------------------------

File: src/components/ui/Button.tsx
================================================================================
import React from 'react';
import clsx from 'clsx';

interface ButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'primary' | 'ghost' | 'light';
  children: React.ReactNode;
}

export const Button = ({ className, variant = 'primary', children, ...props }: ButtonProps) => {
  const baseStyles = 'inline-flex items-center justify-center gap-2 px-4 py-2 rounded-lg font-semibold transition-all duration-200';
  const primaryStyles = 'bg-gradient-to-r from-purple-700 via-purple-800 to-purple-900 text-white hover:scale-105 hover:brightness-110 active:scale-100';
  const ghostStyles = 'bg-neutral-800 hover:bg-neutral-700 text-white border border-neutral-700';
  const lightStyles = 'bg-white text-black hover:scale-105 hover:brightness-90 active:scale-100';

  return (
    <button
      className={clsx(
        baseStyles,
        {
          [primaryStyles]: variant === 'primary',
          [ghostStyles]: variant === 'ghost',
          [lightStyles]: variant === 'light',
        },
        className
      )}
      {...props}
    >
      {children}
    </button>
  );
};


--------------------------------------------------------------------------------

File: src/hooks/useToasts.ts
================================================================================
"use client";

import { useContext } from 'react';
import { ToastContext } from '../contexts/ToastContext';

export function useToasts() {
  const context = useContext(ToastContext);
  if (context === undefined) {
    throw new Error('useToasts must be used within a ToastProvider');
  }
  return context;
}


--------------------------------------------------------------------------------

